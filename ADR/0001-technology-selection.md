# ADR-0001: 프론트엔드 / 백엔드 / DB 기술 선택

## 메타 정보

| 항목 | 내용                                                             |
| ---- | ---------------------------------------------------------------- |
| 상태 | Proposed                                                         |
| 목적 | 로컬 실행 기준 무신사 스타일 웹사이트 구현을 위한 기술 스택 선정 |
| 범위 | 프론트엔드, 백엔드, DB (배포 미포함)                             |

---

## 1. 프론트엔드

### 1.1 컨텍스트

- 요구사항: 반응형(모바일 퍼스트), 이미지 위주 UI, 카드 기반 상품 리스트, 카테고리/필터/정렬, SEO 고려.
- 제약: 배포 없이 로컬 실행 검증만 필요.

### 1.2 결정: **Next.js 15+ (App Router) + TypeScript**

| 선택                  | 기술                |
| --------------------- | ------------------- |
| 프레임워크            | Next.js 15+         |
| 라우팅               | App Router          |
| 스타일링              | Vanilla Extract     |
| 언어                  | TypeScript          |

### 1.3 타당성

- **Next.js 15+**: SSR/SSG로 카테고리·상품 목록/상세 페이지 SEO에 유리. App Router로 레이아웃·로딩·에러 경계를 파일 기반으로 구성 가능. 이미지 최적화(Image), API 라우트 등 내장.
- **App Router**: `app/` 디렉터리 기반 라우팅, Server/Client 컴포넌트 분리로 데이터 페칭·스트리밍과 클라이언트 인터랙션을 명확히 구분.
- **Vanilla Extract**: TypeScript 기반 타입 세이프 CSS-in-JS. 런타임 없이 빌드 타임에 CSS 생성되어 번들 크기·성능에 유리. 스코프된 스타일로 컴포넌트 단위 유지보수 용이. Next.js와 공식 연동 지원.
- **TypeScript**: API 계약(Contract-First)과 연동 시 타입 안정성, 리팩터링·자동완성에 유리.

### 1.4 대안 검토

| 대안             | 장점                                 | 미선택 이유                                                                 |
| ---------------- | ------------------------------------ | --------------------------------------------------------------------------- |
| React + Vite     | 설정 단순, HMR 빠름                  | SEO·SSR을 위해 별도 설정 필요; 카테고리/상품 페이지 SEO 요구사항에 Next가 적합 |
| Tailwind CSS     | 유틸리티 기반, 빠른 UI 작성          | 타입 세이프·스코프 관리 측면에서 Vanilla Extract가 TS 기반 프로젝트에 맞음  |
| CSS Modules      | 번들러 내장, 스코프 기본 지원        | 변수·테마·타입 연동을 위해 빌드 타임 타입 세이프 CSS 선호                    |
| Vue 3 + Vite     | 학습 곡선 완만, 단일 파일 컴포넌트   | 프로젝트 규칙·기존 참조가 React 중심일 가능성 고려                          |
| Vanilla JS/TS    | 의존성 최소                          | 카테고리/필터/상태 관리 규모에서 유지보수 비용 큼                           |

---

## 2. 백엔드

### 2.1 컨텍스트

- REST API 제공: 상품 목록/상세, 카트, 유저, 검색 등.
- Contract-First, 계층형 아키텍처 전제.
- 로컬에서 DB와 함께 단일 머신에서 실행.

### 2.2 결정: **Node.js + Express.js + TypeScript**

| 선택       | 기술          |
| ---------- | ------------- |
| 런타임     | Node.js (LTS) |
| 프레임워크 | Express.js    |
| 언어       | TypeScript    |

### 2.3 타당성

- **Node.js**: 프론트와 동일한 언어(TS)로 타입·모델·DTO 공유 가능, 로컬에서 한 툴체인으로 관리 용이.
- **Express.js**: 사용처·문서·미들웨어 생태계가 풍부함. Contract-First 적용 시 검증(예: express-validator, Zod)을 조합해 사용. 단순한 라우팅·미들웨어 구조로 계층형 아키텍처 구현 용이.
- **TypeScript**: API 스펙과 서버 구현 간 타입 일치, 리팩터링 시 안전성 확보.

### 2.4 대안 검토

| 대안             | 장점                         | 미선택 이유                                                                   |
| ---------------- | ---------------------------- | ----------------------------------------------------------------------------- |
| Fastify          | 낮은 오버헤드, JSON Schema   | 프로젝트에서 Express 생태계·익숙함을 우선함; Contract-First는 검증 라이브러리로 보완 |
| NestJS           | DI, 모듈 구조화              | 로컬 검증용 규모에서는 보일러플레이트가 상대적으로 큼                         |
| FastAPI (Python) | 빠른 개발, OpenAPI 자동 생성 | 프론트/백엔드 이원화 시 타입·모델 공유가 어렵고, 스택이 나뉨                  |

---

## 3. DB

### 3.1 컨텍스트

- 상품, 카테고리, 유저, 장바구니, 주문 등 관계형 데이터.
- 로컬 실행만 필요, 별도 인프라 없이 동작해야 함.

### 3.2 결정: **SQLite (개발/로컬) + PostgreSQL 호환 스키마**

| 선택        | 기술                                                               |
| ----------- | ------------------------------------------------------------------ |
| 로컬 DB     | SQLite 3                                                           |
| 스키마/쿼리 | PostgreSQL과 호환 가능한 형태로 설계 (필수 시 추후 Pg로 전환 용이) |

### 3.3 타당성

- **SQLite**: 별도 DB 서버 설치·실행 불필요. 단일 파일로 백업/복제 간단. 로컬 검증에 충분한 성능과 SQL 지원(FK, 인덱스, 트랜잭션).
- **PostgreSQL 호환 설계**: 타입·제약·네이밍을 PostgreSQL에서도 그대로 쓸 수 있게 두면, 추후 배포나 팀 협업 시 Pg로 전환 시 마이그레이션 비용을 줄일 수 있음. SQLite는 데이터 타입이 유연하므로 Pg 스타일로 쓰는 데 무리 없음.

### 3.4 대안 검토

| 대안                      | 장점                 | 미선택 이유                                                                           |
| ------------------------- | -------------------- | ------------------------------------------------------------------------------------- |
| PostgreSQL만 사용         | 프로덕션과 동일 환경 | 로컬에서 Docker 또는 직접 설치 필요, “로컬에서만 확인” 목표에 비해 초기 설정이 무거움 |
| MySQL/MariaDB             | 널리 사용됨          | 로컬 단일 목적에서는 SQLite가 더 단순; 필요 시 스키마 호환 설계로 Pg 전환 가능        |
| In-memory (예: JSON 파일) | 의존성 없음          | 트랜잭션·관계·인덱스가 필요한 상품/주문/유저 도메인에는 부적합                        |

---

## 4. 로컬 실행 요약

| 계층       | 기술                     | 로컬 실행                                                |
| ---------- | ------------------------ | -------------------------------------------------------- |
| 프론트엔드 | Next.js 15+ App Router   | `pnpm install && pnpm dev` (예: `http://localhost:3000`) |
| 백엔드     | Node + Express + TS      | `pnpm install && pnpm dev` (예: `http://localhost:3001`) |
| DB         | SQLite              | 프로세스 내 파일 DB; 백엔드와 동시 실행                  |

DB 접근은 백엔드에서 `better-sqlite3` 또는 `sql.js` 등으로 연결하면 되며, 별도 DB 서버 기동은 필요 없다.

---

## 5. 참조

- 요구사항: `_docs/requirements/musinsa-website-analysis.md`
- 프로젝트 규칙: Contract-First, 계층형 아키텍처, 코드는 `./musinsa-coding` 하위에 작성.
